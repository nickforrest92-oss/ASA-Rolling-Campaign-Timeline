<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASA Server Timeline Tracker</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Configure Tailwind for Inter font and custom colors -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'ark-dark': '#0f172a', // Slate-900
                        'ark-gray': '#4b5563', 
                        'ark-blue': '#3b82f6', // Blue-500
                        'ark-light': '#f1f5f9', // Slate-100
                        'ark-accent': '#00BCD4', // Cyan-500 (Ascension Arrow Color)
                        'ark-tile-bg': '#1e293b', // Slate-800
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        /* small screen css */
        @media only screen and (max-width: 499px) {
            body {
                /* transform: scale(0.8);
                position: absolute;
                top: -50px; */
            }
            h1{
                font-size: 1.5rem!important;
            }
            #phaseTrackerContainer {
                margin-left: 15px;
                margin-right: 15px;
            }

        }

        /* Tracker Step Styling */
        .tracker-circle {
            width: 28px; 
            height: 28px; 
            border-radius: 50%;
            border: 3px solid;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.5s ease;
            cursor: pointer;
        }
        .tracker-label {
            position: absolute;
            top: 150%;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 0.875rem; 
            text-align: center; 
            transition: color 0.5s ease;
        }
        .progress-line {
            margin-left: 14px;
            margin-right: 14px;
        }
        body {
            height: 100vh;
        }

        #survive-legend-text {
            position: absolute;
            justify-content: center;
        }

        /* --- Unified Server Slot Styling (Label + Tile) --- */
        /* Icon Sizing (Reverted to ensure 8vh consistency) */
        .map-icon {
            width: 10vh;
            height: 10vh;
            object-fit: cover;
            border-radius: 8px; 
            border: 2px solid;
        }
        .disabled-icon-container {
            width: 10vh;
            height: 10vh;
            border-color: #4b5563;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px; 
            border: 2px solid;
        }
        .disabled-icon {
            width: 6vh;
            height: 6vh;
            color: #4b5563;
        }
        
        /* Fixed height for all elements in the row to ensure vertical alignment */
        /* Icon (8vh) + Padding (2rem total) = calc(8vh + 2rem) */
        .server-element-height {
            height: calc(10vh + 2rem); 
        }

        /* 1. Label Block Styling (Matches Tile outer styling) */
        .server-slot-label-block {
            width: 40px; 
            min-width: 40px; /* Prevent shrinking */
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            
            border-radius: 0.75rem; /* rounded-xl */
            border: 1px solid;
        }

        /* Rotated Text inside Label Block */
        .vertical-label-text {
            transform: rotate(-90deg); 
            font-size: 0.875rem;
            font-weight: 600;
            text-align: center;
            white-space: nowrap;
            line-height: 1.2;
            color: #f1f5f9;
        }

        /* 2. Tile Block Styling */
        .tile-container {
            height: 100%;
            padding: 1rem;
            padding-left: 75px; 
            width: 100%; /* Take up remaining space */
            border-radius: 0.75rem;
            border: 1px solid;
        }
    </style>
</head>
<body class="bg-ark-dark text-ark-light font-sans min-h-screen px-2 sm:p-8 overflow-x-hidden">

    <div class="max-w-xl mx-auto w-full">
        <!-- Header -->
        <header class="text-center mb-4">
            <h1 class="text-4xl font-extrabold text-ark-light tracking-tight">ASA Rolling Campaign</h1>
            <!-- <p class="text-ark-light/70 mt-2">Progressive timeline for four rolling ASA servers</p> -->
            
            <!-- Phase Tracker UI (Domino's Style) -->
            <div id="phaseTrackerContainer" class="mt-6 relative px-4 pb-12">
                <!-- Progress Line Container -->
                <div id="progress-line" class="progress-line absolute h-1 bg-gray-600 top-4 left-4 right-4 z-0">
                    <div id="progress-fill" class="h-full bg-ark-accent transition-all duration-500 ease-in-out w-0 rounded-full"></div>
                </div>

                <!-- Tracker Steps (7 Major Phases: 6 steps + End) -->
                <div id="phase-tracker" class="phase-tracker flex justify-between relative z-10">
                    <!-- Steps will be injected by JavaScript -->
                </div>
            </div>
             <!-- Controls: Three New Buttons -->
            <div class="mt-4 flex justify-center space-x-4">
                <button id="previous-button" title="Previous Phase" class="p-3 bg-ark-accent hover:bg-cyan-600 text-white font-semibold rounded-xl shadow-xl transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                    <!-- Left Arrow (Block Triangle) -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 16.59 10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"/></svg>
                </button>

                <button id="live-button" title="Jump to Live Phase" class="px-6 py-3 text-white font-semibold rounded-xl shadow-xl transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                    Live Phase
                </button>

                <button id="next-button" title="Next Phase" class="p-3 bg-ark-accent hover:bg-cyan-600 text-white font-semibold rounded-xl shadow-xl transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                    <!-- Right Arrow (Block Triangle) -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M8.59 16.59 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"/></svg>
                </button>
            </div>

             <!-- Ascension & Transfer Legend Placeholder -->
             <div id="combined-legend" class="mt-4 mb-4 text-center text-sm font-semibold h-5 transition-opacity duration-300 flex items-center justify-center space-y-2" style="flex-direction: column; height: fit-content;">
                <p id="ascension-legend-text" class="text-ark-accent flex items-center">Ascension Notice</p>
                <p id="transfer-legend-text" class="text-ark-blue flex items-center">Item Transfer Notice</p>
                <p id="legend-text" class="text-yellow-500 flex items-center">*Map will be disabled next phase</p>
                <p id="survive-legend-text" class="flex items-center">Transfers closed - Awaiting Ascension</p>
            </div>
        </header>

        <!-- Timeline/SVG Wrapper -->
        <div id="timeline-wrapper" class="relative">
             <!-- The timeline container will now hold the full label+tile rows -->
             <div id="timeline-container" class="mt-4 flex flex-col">
                <!-- Rows will be inserted here by JavaScript -->
             </div>
            
            <!-- SVG Overlay (Absolute positioning ensures it overlays perfectly) -->
            <svg id="ascension-migration-arrows-svg" class="absolute top-0 left-0 w-full h-full" style="pointer-events: none; z-index: 5;" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>
    </div>

    <script>
        // Mapping of Map Names to their uploaded image file paths 
         const imageMap = {
            "The Island": "The Island.jpg",
            "Scorched Earth": "Scorched Earth.jpg",
            "The Center": "The Center.jpg",
            "Aberration": "Aberration.jpg",
            "Ragnarök": "Ragnarök.jpg",
            "Extinction": "Extinction.jpg",
            "Valguero": "Valguero.jpg",
            "Genesis 1": "Genesis 1.jpg",
            "Fjordur": "Fjordur.jpg",
            "Genesis 2": "Genesis 2.jpg",
        };
        
        // Tailwind Colors from config for use in JS/SVG
        const colors = {
            arkDark: '#0f172a', 
            arkGray: '#4b5563', 
            arkLight: '#f1f5f9', 
            arkAccent: '#00BCD4', 
            arkBlue: '#3b82f6',
            arkTileBg: '#1e293b'
        };


        // --- Server Progression Data ---
        // Define common server configurations to simplify the new 15-step array
        const P1_SURVIVE_SERVERS = { "Story 1": "The Island", "Story 2": "Disabled", "Community 1": "Disabled", "Community 2": "Disabled" };
        const P1_ASCENSION_SERVERS = { "Story 1": "The Island", "Story 2": "Scorched Earth", "Community 1": "The Center", "Community 2": "Disabled" };
        const P1_MIGRATION_SERVERS = { "Story 1": "The Island", "Story 2": "Scorched Earth", "Community 1": "The Center", "Community 2": "Disabled" };
        
        const P2_SURVIVE_SERVERS = { "Story 1": "Disabled", "Story 2": "Scorched Earth", "Community 1": "The Center", "Community 2": "Disabled" };
        const P2_ASCENSION_SERVERS = { "Story 1": "Aberration", "Story 2": "Scorched Earth", "Community 1": "The Center", "Community 2": "Ragnarök" };
        const P2_MIGRATION_SERVERS = { "Story 1": "Aberration", "Story 2": "Scorched Earth", "Community 1": "The Center", "Community 2": "Ragnarök" };
        
        const P3_SURVIVE_SERVERS = { "Story 1": "Aberration", "Story 2": "Disabled", "Community 1": "Disabled", "Community 2": "Ragnarök" };
        const P3_ASCENSION_SERVERS = { "Story 1": "Aberration", "Story 2": "Extinction", "Community 1": "Valguero", "Community 2": "Ragnarök" };
        const P3_MIGRATION_SERVERS = { "Story 1": "Aberration", "Story 2": "Extinction", "Community 1": "Valguero", "Community 2": "Ragnarök" };

        const P4_SURVIVE_SERVERS = { "Story 1": "Disabled", "Story 2": "Extinction", "Community 1": "Valguero", "Community 2": "Disabled" };
        const P4_ASCENSION_SERVERS = { "Story 1": "Genesis 1", "Story 2": "Extinction", "Community 1": "Valguero", "Community 2": "Fjordur" };
        const P4_MIGRATION_SERVERS = { "Story 1": "Genesis 1", "Story 2": "Extinction", "Community 1": "Valguero", "Community 2": "Fjordur" };

        const P5_SURVIVE_SERVERS = { "Story 1": "Genesis 1", "Story 2": "Disabled", "Community 1": "Disabled", "Community 2": "Fjordur" };
        const P5_ASCENSION_SERVERS = { "Story 1": "Genesis 1", "Story 2": "Genesis 2", "Community 1": "Disabled", "Community 2": "Fjordur" };
        const P5_MIGRATION_SERVERS = { "Story 1": "Genesis 1", "Story 2": "Genesis 2", "Community 1": "Disabled", "Community 2": "Fjordur" };

        const P6_SURVIVE_SERVERS = { "Story 1": "Genesis 2", "Story 2": "Disabled", "Community 1": "Disabled", "Community 2": "Fjordur" };
        const P6_ASCENSION_SERVERS = { "Story 1": "Genesis 2", "Story 2": "Disabled", "Community 1": "Disabled", "Community 2": "Fjordur" };
        const P6_MIGRATION_SERVERS = { "Story 1": "Genesis 2", "Story 2": "Disabled", "Community 1": "Disabled", "Community 2": "Fjordur" };      

        const timelineData = [
            // Phase 1 (The Island --> Scorched Earth)
            { phase: "1-A", subhead: "Survive & Thrive", servers: P1_SURVIVE_SERVERS },
            { phase: "1-B", subhead: "Ascension", servers: P1_ASCENSION_SERVERS },
            { phase: "1-C", subhead: "Migration", servers: P1_MIGRATION_SERVERS },

            // Phase 2 (Scorched Earth --> Aberration)
            { phase: "2-A", subhead: "Survive & Thrive", servers: P2_SURVIVE_SERVERS },
            { phase: "2-B", subhead: "Ascension", servers: P2_ASCENSION_SERVERS },
            { phase: "2-C", subhead: "Migration", servers: P2_MIGRATION_SERVERS },

            // Phase 3 (Aberration --> Extinction)
            { phase: "3-A", subhead: "Survive & Thrive", servers: P3_SURVIVE_SERVERS },
            { phase: "3-B", subhead: "Ascension", servers: P3_ASCENSION_SERVERS },
            { phase: "3-C", subhead: "Migration", servers: P3_MIGRATION_SERVERS },

            // Phase 4 (Extinction --> Genesis 1)
            { phase: "4-A", subhead: "Survive & Thrive", servers: P4_SURVIVE_SERVERS },
            { phase: "4-B", subhead: "Ascension", servers: P4_ASCENSION_SERVERS },
            { phase: "4-C", subhead: "Migration", servers: P4_MIGRATION_SERVERS },

            // Phase 5 (Genesis 1 --> Genesis 2)
            { phase: "5-A", subhead: "Survive & Thrive", servers: P5_SURVIVE_SERVERS },
            { phase: "5-B", subhead: "Ascension", servers: P5_ASCENSION_SERVERS },
            { phase: "5-C", subhead: "Migration", servers: P5_MIGRATION_SERVERS },

            // Phase 6 (Genesis 2 --> Campaign End)
            { phase: "6-A", subhead: "Survive & Thrive", servers: P6_SURVIVE_SERVERS },
            { phase: "6-B", subhead: "Final Boss", servers: P6_ASCENSION_SERVERS },
            { phase: "End", subhead: "Campaign", servers: P6_MIGRATION_SERVERS },
        ];
        // --- End of Timeline Data Update ---


        // State variables
        let currentPhaseIndex = 0; 
        const totalPhases = timelineData.length;
        let livePhaseIndex = 0; // Set initial live phase to Phase 3-A

        // DOM Elements
        const timelineContainer = document.getElementById('timeline-container');
        const phaseTracker = document.getElementById('phase-tracker');
        const progressFill = document.getElementById('progress-fill');
        
        // New DOM references for the three buttons and legend
        const previousButton = document.getElementById('previous-button');
        const liveButton = document.getElementById('live-button');
        const nextButton = document.getElementById('next-button');
        
        // References for the combined legend
        const combinedLegendContainer = document.getElementById('combined-legend');
        const ascensionLegendText = document.getElementById('ascension-legend-text');
        const transferLegendText = document.getElementById('transfer-legend-text');
        const legendText = document.getElementById('legend-text');
        const surviveLegendText = document.getElementById('survive-legend-text'); 
        const ascensionSvg = document.getElementById('ascension-migration-arrows-svg'); // SVG reference
        const labelColumn = document.getElementById('label-column'); // No longer needed, but keeping variable name convention

        // Initial setup for the 7 tracker steps
        function setupTrackerSteps() {
            let trackerHtml = '';
            for (let i = 1; i <= 7; i++) {
                // Determine if it's the final 'End' flag (Step 7)
                const isFinalStep = (i === 7);
                
                let stepContent;
                if (isFinalStep) {
                    // Flag icon for the final step
                    stepContent = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-flag-fill" viewBox="0 0 16 16">
                            <path d="M14.778.085A.5.5 0 0 1 15 .5V8a.5.5 0 0 1-.314.464L14.5 8l.186.464-.003.001-.006.003-.023.009a12 12 0 0 1-.397.15c-.264.095-.631.223-1.047.35-.816.252-1.879.523-2.71.523-.847 0-1.548-.28-2.158-.525l-.028-.01C7.68 8.71 7.14 8.5 6.5 8.5c-.7 0-1.638.23-2.437.477A20 20 0 0 0 3 9.342V15.5a.5.5 0 0 1-1 0V.5a.5.5 0 0 1 1 0v.282c.226-.079.496-.17.79-.26C4.606.272 5.67 0 6.5 0c.84 0 1.524.277 2.121.519l.043.018C9.286.788 9.828 1 10.5 1c.7 0 1.638-.23 2.437-.477a20 20 0 0 0 1.349-.476l.019-.007.004-.002h.001"/>
                        </svg>
                    `;
                } else {
                    stepContent = `<span class="text-sm font-bold text-gray-500">${i}</span>`;
                }

                trackerHtml += `
                    <div class="tracker-step relative flex flex-col items-center">
                        <div id="step-${i}" class="tracker-circle border-gray-500 bg-ark-dark" onclick="jumpToClickedPhaseIndex(${i})">
                            ${stepContent}
                        </div>
                        <span id="label-${i}" class="tracker-label text-gray-500 font-semibold"></span>
                    </div>
                `;
            }
            phaseTracker.innerHTML = trackerHtml;
        }

        // Helper function to create the icon HTML (Image or Disabled SVG)
        function getIconHtml(mapName, isDisabling) {
            
            if (mapName === "Disabled") {
                // Disabled Icon (Ban) - Gray color
                return `<div class="disabled-icon-container" style="border-color:${colors.arkGray}">
                            <svg xmlns="http://www.w3.org/2000/svg" class="disabled-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="m4.93 4.93 14.14 14.14"/></svg>
                        </div>`;
            } else {
                const imageUrl = imageMap[mapName];
                // Use yellow-500 border if the map is about to be disabled
                const borderColor = isDisabling ? 'border-yellow-500' : 'border-ark-blue/50'; 
                const altText = `Icon for ${mapName} map`;
                
                // Use custom colors for the border in the inline style for dynamic generation
                return `<img src="${imageUrl}" alt="${altText}" class="map-icon" style="border-color: ${isDisabling ? 'rgb(234 179 8)' : 'rgba(59, 130, 246, 0.5)'}"
                            onerror="this.onerror=null; this.src='https://placehold.co/8vhx8vh/64748b/ffffff?text=LOCAL'; this.style.borderColor='${colors.arkAccent}';" 
                        />`;
            }
        }
        
        // NEW Function to generate the combined label and tile row
        function getServerRowHtml(slotName, mapName, isDisabling, slotIndex) {
            const isDisabled = mapName === "Disabled";
            
            // --- 1. Determine Shared Style Classes ---
            let baseColorClass, finalBorderColor, finalBgColor;
            
            if (isDisabled) {
                // Disabled Style
                finalBorderColor = colors.arkGray;
                finalBgColor = colors.arkDark + '80'; // ark-dark/50 (using 80 for more visibility)
            } else if (isDisabling) {
                // Disabling Soon Style
                finalBorderColor = 'rgb(234 179 8)'; // yellow-500
                finalBgColor = colors.arkTileBg; 
            } else {
                // Active Style
                finalBorderColor = colors.arkBlue + '80'; // ark-blue/50
                finalBgColor = colors.arkTileBg;
            }

            // --- 2. Generate Label Block HTML ---
            const [type, num] = slotName.split(' ');
            const labelText = type + '\n' + num;

            const labelBlockHtml = `
                <div class="server-slot-label-block server-element-height" style="border-color: ${finalBorderColor}; background-color: ${finalBgColor};">
                    <div class="vertical-label-text text-ark-light">
                        ${labelText}
                    </div>
                </div>
            `;


            // --- 3. Generate Tile Block HTML ---
            
            // Text color based on status
            let mapTextClasses = 'text-xl flex-grow min-w-0';
            let tooltipText = mapName;
            let displayMapName = mapName;

            if (isDisabled) {
                mapTextClasses += ' text-ark-gray italic';
            } else if (isDisabling) {
                mapTextClasses += ' text-yellow-500 font-semibold';
                tooltipText += " - *will be disabled next phase";
                displayMapName += '*';
            } else {
                mapTextClasses += ' text-ark-light font-semibold';
            }

            const slotAttribute = `data-slot-index="${slotIndex}"`;

            const tileBlockHtml = `
                <div class="tile-container server-element-height flex items-center shadow-lg" title="${tooltipText}" ${slotAttribute} style="border-color: ${finalBorderColor}; background-color: ${finalBgColor};">
                    <!-- Icon Placeholder -->
                    <div class="mr-4 flex-shrink-0">
                        ${getIconHtml(mapName, isDisabling)}
                    </div>

                    <!-- Map Name / Status -->
                    <div class="${mapTextClasses}">
                        ${displayMapName}
                    </div>
                </div>
            `;
            
            // --- 4. Combine into Row ---
            return `
                <div class="server-slot-row flex items-start space-x-2 mb-4">
                    ${labelBlockHtml}
                    ${tileBlockHtml}
                </div>
            `;
        }


        // --- Draw Arrow Function (Minimal update for new alignment) ---
        function drawArrow(sourceIndex, targetIndex, strokeColor, isRequired, arrowId) {
            const svg = document.getElementById('ascension-migration-arrows-svg');
            
            const tiles = document.querySelectorAll('#timeline-container .tile-container');

            if (!tiles || tiles.length < 2 || sourceIndex < 0 || targetIndex < 0 || sourceIndex >= tiles.length || targetIndex >= tiles.length) return;

            const sourceTile = tiles[sourceIndex];
            const targetTile = tiles[targetIndex];

            // Use the parent row element's position for accurate offset
            const timelineRect = document.getElementById('timeline-container').getBoundingClientRect();
            const sourceRect = sourceTile.parentElement.getBoundingClientRect(); // Get row rect
            const targetRect = targetTile.parentElement.getBoundingClientRect(); // Get row rect

            // Calculate Y centers relative to the SVG container
            const Y_start = sourceRect.top + sourceRect.height / 2 - timelineRect.top;
            const Y_end = targetRect.top + targetRect.height / 2 - timelineRect.top;

            // X coordinates for the vertical line segment (relative to SVG's left edge (0,0))
            // These coordinates fit within the new 80px label block area
            const X_VERTICAL_ASCENSION = 75;
            const X_VERTICAL_TRANSFER1 = 75;
            const X_VERTICAL_TRANSFER2 = 95;
            
            // X_ENTRY: The entry point must be on the boundary between the 80px label block and the tile
            // The label block is 80px, space-x-2 is 8px. The tile starts at 88px.
            const X_ENTRY = 120; 

            let X_VERTICAL;
            if (arrowId === 'ascension') {
                X_VERTICAL = X_VERTICAL_ASCENSION;
            } else if (arrowId === 'transfer1') {
                X_VERTICAL = X_VERTICAL_TRANSFER1; 
            } else { // 'transfer2'
                X_VERTICAL = X_VERTICAL_TRANSFER2; 
            }

            // Define the path for the L-shaped arrow
            const pathData = [
                // Start: Horizontal segment begins at X_ENTRY (where label block ends)
                `M ${X_ENTRY} ${Y_start}`, 
                // Horizontal segment 1 (to the vertical line)
                `L ${X_VERTICAL} ${Y_start}`,
                // Vertical segment (down or up)
                `L ${X_VERTICAL} ${Y_end}`,
                // Horizontal segment 2 (back into the target tile area)
                `L ${X_ENTRY} ${Y_end}`
            ].join(' ');

            const strokeWidth = 8;
            // Dashed for 'B' (Available), Solid for 'C' (Required)
            const dashArray = isRequired ? '0' : '5, 10'; 

            // Create the path element
            const arrow = document.createElementNS("http://www.w3.org/2000/svg", 'path');
            arrow.setAttribute('d', pathData);
            arrow.setAttribute('stroke', strokeColor);
            arrow.setAttribute('stroke-width', strokeWidth);
            arrow.setAttribute('fill', 'none');
            arrow.setAttribute('stroke-dasharray', dashArray);
            arrow.setAttribute('stroke-linecap', 'round');
            
            // Create the arrowhead marker (reusable definition, using unique ID for color)
            const markerId = `${arrowId}-arrowhead`;
            
            let marker = document.getElementById(markerId);
            if (!marker) {
                marker = document.createElementNS("http://www.w3.org/2000/svg", 'marker');
                marker.setAttribute('id', markerId);
                marker.setAttribute('viewBox', '0 0 10 10');
                marker.setAttribute('refX', '5');
                marker.setAttribute('refY', '5');
                marker.setAttribute('markerWidth', '4');
                marker.setAttribute('markerHeight', '4');
                marker.setAttribute('orient', 'auto-start-reverse');
                
                const polygon = document.createElementNS("http://www.w3.org/2000/svg", 'polygon');
                polygon.setAttribute('points', '2 2, 7 5, 2 8');
                polygon.setAttribute('fill', strokeColor);
                marker.appendChild(polygon);
                svg.appendChild(marker);
            } else {
                // Ensure marker color is correct if the function is called multiple times
                marker.querySelector('polygon').setAttribute('fill', strokeColor);
            }

            // Apply marker to the path (points towards the target)
            arrow.setAttribute('marker-end', `url(#${markerId})`);
            
            svg.appendChild(arrow);
        }

        
        // Function to update the visual tracker
        function updateTracker() {
            const currentData = timelineData[currentPhaseIndex];
            
            // Calculate progress percentage
            const transitions = totalPhases; 
            let progress;
            
            // Calculate progress line fill percentage
            // Final Phase-B
            if (currentPhaseIndex === (totalPhases - 2)){
                progress = (currentPhaseIndex / (transitions - 0.66)) * 100;
            }
            // Final Phase-C
            else if (currentPhaseIndex === (totalPhases - 1)){
                progress = (currentPhaseIndex / (transitions - 1)) * 100;
            }
            else {
                progress = (currentPhaseIndex / transitions) * 100;
            }
            progressFill.style.width = `${progress}%`;

            // Calculate major phases
            let currentMajorPhase = Math.floor(currentPhaseIndex / 3) + 1;
            const liveMajorPhase = Math.floor(livePhaseIndex / 3) + 1;
            const finalMajorPhase = Math.floor(totalPhases / 3) + 1;
            let isFinalPhase = false;
            let finalCircle = document.getElementById(`step-${finalMajorPhase}`);
            let finalLabel = document.getElementById(`label-${finalMajorPhase}`); 

            for (let i = 1; i <= 6; i++) {
                let circle = document.getElementById(`step-${i}`);
                let label = document.getElementById(`label-${i}`);
                                   

                if(currentPhaseIndex === totalPhases - 1){
                    currentMajorPhase++;
                    isFinalPhase = true;
                }

                // Reset classes for all final element
                finalCircle.classList.remove('border-ark-accent', 'bg-ark-accent', 'border-gray-500', 'bg-ark-dark', 'bg-ark-light', 'border-ark-light');
                finalCircle.firstElementChild.classList.remove('text-ark-light', 'text-ark-dark', 'text-gray-500');                           
                finalCircle.classList.add('border-gray-500', 'bg-ark-dark');
                finalCircle.firstElementChild.classList.add('text-gray-500');
                finalLabel.classList.remove('text-ark-accent', 'text-ark-light', 'text-gray-500');     
                finalLabel.classList.add('text-gray-500');
                finalLabel.textContent = "";

                // Reset classes for all other elements
                circle.classList.remove('border-ark-accent', 'bg-ark-accent', 'border-gray-500', 'bg-ark-dark', 'bg-ark-light', 'border-ark-light');
                circle.firstElementChild.classList.remove('text-ark-light', 'text-ark-dark', 'text-gray-500');
                label.classList.remove('text-ark-accent', 'text-ark-light', 'text-gray-500');
                

                if (i < currentMajorPhase) {
                    // Completed Phase
                    circle.classList.add('border-ark-accent', 'bg-ark-accent');
                    circle.firstElementChild.classList.add('text-ark-light');
                    label.classList.add('text-ark-light');
                    label.textContent = "";
                } else if (i === currentMajorPhase) {
                    // Active Phase - Display the full phase (e.g., Phase 3-B) and subhead (Migration)
                    circle.classList.add('border-ark-accent', 'bg-ark-light');
                    circle.firstElementChild.classList.add('text-ark-dark');
                    label.classList.add('text-ark-accent', 'text-ark-light');

                    // Inject multi-line HTML content for the active phase label
                    label.innerHTML = `
                        <div class="font-bold text-ark-light">${currentData.phase}</div>
                        <div class="text-xs font-semibold text-ark-accent">${currentData.subhead}</div>
                    `;
                } else {
                    // Pending Phase
                    circle.classList.add('border-gray-500', 'bg-ark-dark');
                    circle.firstElementChild.classList.add('text-gray-500');
                    label.classList.add('text-gray-500');
                    label.textContent = "";
                }
                if (isFinalPhase) {
                    circle = document.getElementById(`step-${i+1}`);
                    circle.classList.remove('border-ark-accent', 'bg-ark-accent', 'border-gray-500', 'bg-ark-dark', 'bg-ark-light', 'border-ark-light');
                    circle.classList.add('border-ark-accent', 'bg-ark-light');
                    circle.firstElementChild.classList.add('text-ark-light');
                    label = document.getElementById(`label-${i+1}`);
                    label.classList.add('text-ark-accent', 'text-ark-light');

                    // Inject multi-line HTML content for the active phase label
                    label.innerHTML = `
                        <div class="font-bold text-ark-light">${currentData.phase}</div>
                        <div class="text-xs font-semibold text-ark-accent">${currentData.subhead}</div>
                    `;
                }
            }
             
            if (currentPhaseIndex != livePhaseIndex) {
                let circle = document.getElementById(`step-${liveMajorPhase}`);
                let label = document.getElementById(`label-${liveMajorPhase}`);
                circle.classList.remove('border-ark-accent', 'bg-ark-accent', 'border-gray-500', 'bg-ark-dark', 'border-ark-light', 'bg-ark-light');
                circle.firstElementChild.classList.remove('text-ark-dark', 'text-ark-light', 'text-gray-500');
                label.classList.remove('text-ark-accent', 'text-ark-light', 'text-gray-500');
                circle.classList.add('border-ark-light', 'bg-ark-dark');
                circle.firstElementChild.classList.add('text-ark-light');
                label.classList.add('text-ark-light');
            }
        }
        
        // New function to handle button states
        function updateButtonStates() {
            // Reset button classes
            [previousButton, liveButton, nextButton].forEach(button => {
                button.classList.remove('bg-ark-accent', 'bg-ark-gray', 'hover:bg-cyan-600', 'hover:bg-gray-500');
                button.disabled = false;
            });
            
            // Previous button logic
            if (currentPhaseIndex === 0) {
                previousButton.disabled = true;
                previousButton.classList.add('bg-ark-gray', 'hover:bg-gray-500');
            } else {
                previousButton.classList.add('bg-ark-accent', 'hover:bg-cyan-600');
            }

            // Next button logic / Campaign Complete
            if (currentPhaseIndex >= totalPhases - 1) {
                nextButton.disabled = true;
                nextButton.classList.add('bg-ark-gray', 'hover:bg-gray-500');
            } else {
                nextButton.classList.add('bg-ark-accent', 'hover:bg-cyan-600');
                liveButton.textContent = "Live Phase";
            }

            // Live button logic (Color changes based on currentPhaseIndex vs livePhaseIndex)
            if (currentPhaseIndex === livePhaseIndex) {
                // Disabled style when already at the live phase
                liveButton.classList.add('bg-ark-gray', 'hover:bg-gray-500');
                liveButton.disabled = true;
                liveButton.title = "Already viewing Live Phase"; 
            } else {
                // Accent color when not at the live phase
                liveButton.classList.add('bg-ark-accent', 'hover:bg-cyan-600');
                liveButton.disabled = false;
                liveButton.title = "Jump to the Live Phase";
            }
        }


        // Main function to render the current phase data
        function renderTimeline() {
            
            // 1. Update Phase Tracker UI
            updateTracker();

            // 2. Update Tiles and Labels
            let rowsHtml = '';
            const currentData = timelineData[currentPhaseIndex];
            const nextData = timelineData[currentPhaseIndex + 1];

            // The required vertical order of slots
            const slotOrder = ["Story 1", "Story 2", "Community 1", "Community 2"];
            
            // NEW FLAG: Track if any map in the current view is disabling
            let isAnyMapDisabling = false;

            slotOrder.forEach((slotName, index) => {
                const currentMapName = currentData.servers[slotName];
                let isDisabling = false;

                if (nextData) {
                    const nextMapName = nextData.servers[slotName];
                    
                    // The map is currently active (not Disabled) AND will be Disabled in the next phase
                    if (currentMapName !== "Disabled" && nextMapName === "Disabled") {
                        isDisabling = true;
                        isAnyMapDisabling = true; // Set the flag
                    }
                }
                
                rowsHtml += getServerRowHtml(slotName, currentMapName, isDisabling, index);
            });
            
            // Render the combined rows
            timelineContainer.innerHTML = rowsHtml;

            // 3. Update Button State
            updateButtonStates();
            
            // 4. Update Legend Visibility (Map Disabling)
            if (isAnyMapDisabling) {
                legendText.classList.remove('opacity-0');
                legendText.classList.add('opacity-100');
            } else {
                legendText.classList.remove('opacity-100');
                legendText.classList.add('opacity-0');
            }

            // 5. Draw Arrows & Update Legend (Ascension & Transfer)
            
            // Reset SVG and legend content
            ascensionSvg.innerHTML = '';
            //ascensionLegendText.innerHTML = '';
            //transferLegendText.innerHTML = '';

            let isAscensionActive = false;
            let isTransferActive = false;
            
            const currentPhase = currentData.phase;
            const phaseSuffix = currentPhase.slice(-2); // e.g., "-A", "-B", "-C"
            // The current major phase (1-6)
            const majorPhase = Math.floor(currentPhaseIndex / 3) + 1;
            const ascensionRequired = phaseSuffix === '-C';
            
            if (phaseSuffix === '-A') { // Any Sub-Phase 'A'
                // show subphase 'A' legend text - hide subphase 'B' & 'C' legend text
                surviveLegendText.classList.remove('opacity-0');
                surviveLegendText.classList.add('opacity-100');
                ascensionLegendText.classList.remove('opacity-100');
                ascensionLegendText.classList.add('opacity-0');
                transferLegendText.classList.remove('opacity-100');
                transferLegendText.classList.add('opacity-0');                             
            }
            else if (majorPhase <= 5) { // Any Sub-Phase 'B' or 'C' before Phase 5              
                 // hide subphase 'A' legend text - show subphase 'B' & 'C' legend text 
                surviveLegendText.classList.remove('opacity-100');
                surviveLegendText.classList.add('opacity-0');
                ascensionLegendText.classList.remove('opacity-0');
                ascensionLegendText.classList.add('opacity-100');
                transferLegendText.classList.remove('opacity-0');
                transferLegendText.classList.add('opacity-100');  

                // --- A. TRANSFER ARROW LOGIC (Tame & Item) ---
                let transferSource1 = -1; // Story Map Source
                let transferSource2 = -1; // Community Map Source
                let transferTarget = -1;  // New Community Target

                switch (majorPhase) {
                    case 1: 
                        // S1(0) transfers to NS1(2)
                        transferSource1 = 0; 
                        transferTarget = 2; 
                        break;
                    case 2:
                        // S2(1) transfers to NS2(3)
                        // NS1(2) transfers to NS2(3)
                        transferSource1 = 1; 
                        transferSource2 = 2; 
                        transferTarget = 3;
                        break;
                    case 3:
                        // S1(0) transfers to NS1(2)
                        // NS2(3) transfers to NS1(2)
                        transferSource1 = 0; 
                        transferSource2 = 3; 
                        transferTarget = 2;
                        break;
                    case 4:
                        // S2(1) transfers to NS2(3)
                        // NS1(2) transfers to NS2(3)
                        transferSource1 = 1; 
                        transferSource2 = 2; 
                        transferTarget = 3;
                        break;
                    case 5:
                        // No new Community map in 5-B/C
                        transferLegendText.classList.remove('opacity-100');
                        transferLegendText.classList.add('opacity-0'); 
                        break;
                }

                if (transferTarget !== -1) {
                    isTransferActive = true;
                    const transferColor = colors.arkBlue;
                    
                    // Draw Transfer Arrow 1 (Story Map Source)
                    if (transferSource1 !== -1) {
                        setTimeout(() => drawArrow(transferSource1, transferTarget, transferColor, ascensionRequired, 'transfer1'), 0);
                    }
                    // Draw Transfer Arrow 2 (Existing Community Source)
                    if (transferSource2 !== -1) {
                        setTimeout(() => drawArrow(transferSource2, transferTarget, transferColor, ascensionRequired, 'transfer2'), 0);
                    }
                }

                // --- B. ASCENSION ARROW LOGIC (Character) ---
                let ascSourceIndex = -1;
                let ascTargetIndex = -1;
                
                // Ascension always goes from the PREVIOUS Story map to the NEW Story map.
                switch (majorPhase) {
                    case 1: // Island -> Scorched Earth (0 -> 1)
                    case 3: // Aberration -> Extinction (0 -> 1)
                    case 5: // Genesis 1 -> Genesis 2 (0 -> 1)
                        ascSourceIndex = 0; // Story 1
                        ascTargetIndex = 1; // Story 2
                        break;
                    case 2: // Scorched Earth -> Aberration (1 -> 0)
                    case 4: // Extinction -> Genesis 1 (1 -> 0)
                        ascSourceIndex = 1; // Story 2
                        ascTargetIndex = 0; // Story 1
                        break;
                }

                if (ascSourceIndex !== -1) {
                    isAscensionActive = true;
                    // Draw Ascension Arrow (Cyan/ark-accent)
                    setTimeout(() => drawArrow(ascSourceIndex, ascTargetIndex, colors.arkAccent, ascensionRequired, 'ascension'), 0);
                }
            }

            if (majorPhase === 6) { // Any Sub-Phase of Final Phase
                surviveLegendText.innerHTML = "Transfers Closed for final phase";
                surviveLegendText.classList.remove('opacity-0');
                surviveLegendText.classList.add('opacity-100');
                ascensionLegendText.classList.remove('opacity-100');
                ascensionLegendText.classList.add('opacity-0');
                transferLegendText.classList.remove('opacity-100');
                transferLegendText.classList.add('opacity-0');
            }
            else { // Any Phase other than final Phase
                surviveLegendText.innerHTML = "Transfers closed - Awaiting Ascension";
            } 


            // --- C. COMBINED LEGEND GENERATION ---
            const dashArray = ascensionRequired ? '0' : '5, 3'; // Same dash settings for legend SVG

            if (isAscensionActive || isTransferActive) {
                // 1. Ascension Legend Content
                if (isAscensionActive) {
                    const ascColor = colors.arkAccent;
                    const ascInlineSvg = `<svg class="h-4 w-6 mr-2" viewBox="0 0 20 10" style="stroke: ${ascColor};"><line x1="0" y1="5" x2="20" y2="5" stroke-width="3" stroke-linecap="round" stroke-dasharray="${dashArray}" /></svg>`;
                    
                    if (ascensionRequired) {
                        ascensionLegendText.innerHTML = `${ascInlineSvg} <span>Ascension <u>required</u> by end of phase</span>`;
                    } else {
                        ascensionLegendText.innerHTML = `${ascInlineSvg} <span>Ascension Available</span>`;
                    }
                }
                
                // 2. Transfer Legend Content
                if (isTransferActive) {
                    const transColor = colors.arkBlue;
                    const transInlineSvg = `<svg class="h-4 w-6 mr-2" viewBox="0 0 20 10" style="stroke: ${transColor};"><line x1="0" y1="5" x2="20" y2="5" stroke-width="3" stroke-linecap="round" stroke-dasharray="${dashArray}" /></svg>`;

                    if (ascensionRequired) {
                        transferLegendText.innerHTML = `${transInlineSvg} <span>Tame & Item Transfers <u>required</u> by end of phase</span>`;
                    } else {
                        transferLegendText.innerHTML = `${transInlineSvg} <span>Tame & Item Transfers Available</span>`;
                    }
                }
            } else {
                ascensionSvg.innerHTML = ''; // Clear main SVG
            }
        }

        // Function to go back one phase
        function previousPhase() {
            if (currentPhaseIndex > 0) {
                currentPhaseIndex--;
                renderTimeline();
            }
        }
        
        // Function to jump to the current live phase
        function jumpTolivePhaseIndex() {
            currentPhaseIndex = livePhaseIndex;
            renderTimeline();
        }

        // Function to jump to the clicked phase
        function jumpToClickedPhaseIndex(clickedMajorPhaseIndex) {
            let clickedPhaseIndex = clickedMajorPhaseIndex * 3 - 3;
            if (clickedPhaseIndex === totalPhases)
                clickedPhaseIndex--;
            currentPhaseIndex = clickedPhaseIndex;
            renderTimeline();
        }

        // Function to advance to the next phase (Renamed from advancePhase)
        function nextPhase() {
            if (currentPhaseIndex < totalPhases - 1) {
                currentPhaseIndex++;
                renderTimeline();
            }
        }

        // Attach event listeners for the new buttons
        previousButton.addEventListener('click', previousPhase);
        liveButton.addEventListener('click', jumpTolivePhaseIndex);
        nextButton.addEventListener('click', nextPhase);

        // Initialize the timeline on load
        window.onload = () => {
            setupTrackerSteps(); // Create the 7 step elements
            // Start the view at the current live phase (index 6) for better visibility
            currentPhaseIndex = livePhaseIndex;
            renderTimeline(); // Render initial state
        };
    </script>
</body>
</html>
